plugins {
    id 'org.openapi.generator'
}

import com.adyen.sdk.Service
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.openapitools.generator.gradle.plugin.tasks.GenerateTask

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

// list of services to be generated
// services are APIs with multiple tags: the generation will create a service class/file for each tag
// smallServices are APIs with a single tag 'General': the generation will create a single class/file
List<Service> services = [
        // Payments
        new Service(name: 'Checkout', version: 71, tag: 'Payments'),
        new Service(name: 'Payout', version: 68, tag: 'Payments'),
        new Service(name: 'Recurring', version: 68, small: true, tag: 'Payments'),
        new Service(name: 'BinLookup', version: 54, small: true, tag: 'Payments'),
        new Service(name: 'PosMobile', spec: 'SessionService', version: 68, small: true, tag: 'Payments'),
        new Service(name: 'PaymentsApp', spec: 'PaymentsAppService', version: 1, small: true, tag: 'Payments'),
        new Service(name: 'Disputes', spec: 'DisputeService', version: 30, small: true, tag: 'Payments'),
        new Service(name: 'StoredValue', version: 46, small: true, tag: 'Payments'),
        // Classic Payments
        new Service(name: 'Payment', version: 68, small: true, tag: 'Payments'),
        // Management
        new Service(name: 'Management', version: 3, tag: 'Management'),
        new Service(name: 'BalanceControl', version: 1, small: true, tag: 'Management'),
        // Adyen for Platforms
        new Service(name: 'LegalEntityManagement', spec: 'LegalEntityService', version: 4, tag: 'Platforms'),
        new Service(name: 'BalancePlatform', version: 2, tag: 'Platforms'),
        new Service(name: 'Transfers', spec: 'TransferService', version: 4, tag: 'Platforms'),
        new Service(name: 'DataProtection', version: 1, small: true, tag: 'Platforms'),
        new Service(name: 'SessionAuthentication', version: 1, tag: 'Platforms'),
        // Webhooks
        new Service(name: 'ConfigurationWebhooks', spec: 'BalancePlatformConfigurationNotification', version: 2, tag: 'Webhooks'),
        new Service(name: 'AcsWebhooks', spec: 'BalancePlatformAcsNotification', version: 1, tag: 'Webhooks'),
        new Service(name: 'ReportWebhooks', spec: 'BalancePlatformReportNotification', version: 1, tag: 'Webhooks'),
        new Service(name: 'TransferWebhooks', spec: 'BalancePlatformTransferNotification', version: 4, tag: 'Webhooks'),
        new Service(name: 'TransactionWebhooks', spec: 'BalancePlatformTransactionNotification', version: 4, tag: 'Webhooks'),
        new Service(name: 'ManagementWebhooks', spec: 'ManagementNotificationService', version: 3, tag: 'Webhooks'),
        new Service(name: 'DisputeWebhooks', spec: 'BalancePlatformDisputeNotification', version: 1, tag: 'Webhooks'),
        new Service(name: 'NegativeBalanceWarningWebhooks', spec: 'BalancePlatformNegativeBalanceCompensationWarningNotification', version: 1, tag: 'Webhooks'),
        new Service(name: 'BalanceWebhooks', spec: 'BalancePlatformBalanceNotification', version: 1, tag: 'Webhooks'),
        new Service(name: 'TokenizationWebhooks', spec: 'TokenizationNotification', version: 1, tag: 'Webhooks')
]

ext {
    generator = project.name
    templates = 'templates'
    serviceName = ''
    removeTags = true
    setProperty('services', services)
    smallServices = services.findAll { it.small }

    serviceNaming = services.collectEntries { [it.id, it.name] }
    serviceNamingCamel = services.collectEntries {
        [it.id, it.name.substring(0, 1).toLowerCase() + it.name.substring(1)]
    }
}

// Generate a full client for each service
services.each { Service svc ->
    def generate = tasks.register("generate$svc.name", GenerateTask) {
        group 'generate'
        description "Generate a $project.name client for $svc.name."
        dependsOn 'cloneRepo'
        dependsOn ':specs'

        // Current service being processed
        ext.serviceId = svc.id
        project.ext.serviceName = svc.name

        generatorName.set(project.ext.generator as String)
        inputSpec.set("$rootDir/schema/json/${svc.filename}")
        outputDir.set("$buildDir/services/${svc.id}")
        templateDir.set("$projectDir/repo/$project.ext.templates")
        engine.set('mustache')
        validateSpec.set(false)
        skipValidateSpec.set(true)
        reservedWordsMappings.set([
                "configuration": "configuration"
        ])
        additionalProperties.set([
                'serviceName': project.ext.serviceName,
        ])
        globalProperties.set([
                'modelDocs' : 'false',
                'modelTests': 'false'
        ])

        if (project.ext.has('configFile')) {
            configFile.set("$projectDir/repo/$project.ext.configFile")
        }
    }

    tasks.register(svc.id) {
        group 'service'
        description "Base task for $svc.name."
        dependsOn generate
    }
}

// generate all services
tasks.register('services') {
    description 'Generate code for multiple services.'
    dependsOn services.collect { it.id }
}

// generate services with tag 'Payments'
tasks.register('paymentsApis') {
    description 'Generate code for Payments services.'
    dependsOn services.findAll { it.tag == 'Payments' }.collect { it.id }
}

// generate services with tag 'Management'
tasks.register('managementApis') {
    description 'Generate code for Management services.'
    dependsOn services.findAll { it.tag == 'Management' }.collect { it.id }
}

// generate services with tag 'Platforms'
tasks.register('platformsApis') {
    description 'Generate code for Platforms services.'
    dependsOn services.findAll { it.tag == 'Platforms' }.collect { it.id }
}

// generate services with tag 'Webhooks'
tasks.register('webhooks') {
    description 'Generate code for Webhooks.'
    dependsOn services.findAll { it.tag == 'Webhooks' }.collect { it.id }
}

tasks.named('generateCheckout', GenerateTask) {
    if (project.name == 'node') {
        // generator v5 does not support inlineSchemaNameMappings
        return
    }
    inlineSchemaNameMappings.set([
            'PaymentRequest_paymentMethod'        : 'CheckoutPaymentMethod',
            'DonationPaymentRequest_paymentMethod': 'DonationPaymentMethod',
    ])
}

tasks.register('cloneRepo', Exec) {
    group 'setup'
    def uri = "https://github.com/Adyen/adyen-$project.name-api-library.git"
    def dest = 'repo'
    description "Clone this project's repository."
    commandLine 'git', 'clone', uri, '--single-branch', dest
    outputs.dir dest
    onlyIf { !file(dest).exists() }
}

// Disable generator caching
tasks.withType(GenerateTask).configureEach {
    outputs.upToDateWhen { false }
    outputs.cacheIf { false }
}

tasks.register('cleanRepo', Delete) {
    group 'clean'
    description 'Clean this project state'
    delete layout.buildDirectory
    doLast {
        exec {
            // cleanTracked: discard changes to existing files
            commandLine 'git', 'checkout', '.'
            workingDir 'repo'
        }
        exec {
            // cleanUntracked: discard unknown files
            commandLine 'git', 'clean', '-f', '-d'
            workingDir 'repo'
        }
    }
}

tasks.register('addPMTable', Copy) {
    dependsOn("cloneRepo")
    dependsOn(":pmTable")
    from(rootProject.file('PaymentMethodOverview.md'))
    into layout.projectDirectory.dir("repo")
}

// update OpenAPI file of the smallService to rename the tag from 'General' to the name of the API (i.e. Binlookup)
// this is necessary to generate the service/class file using the name of the API (instead of General)
project.ext.smallServices.each { Service svc ->
    def ungroup = tasks.register("ungroup${svc.name}") {
        group 'specs'
        description "Update tags in ${svc.name}"
        dependsOn ':specs'
        onlyIf { project.ext.removeTags }
        doLast {
            def specFile = file("$rootDir/schema/json/${svc.filename}")
            def json = new JsonSlurper().parse(specFile)

            json["paths"].each { Map.Entry endpoint ->
                endpoint.value.each { Map.Entry httpMethod ->
                    if (httpMethod.value.containsKey("tags") && httpMethod.value.tags instanceof List) {
                        // Rename tag associated with endpoint
                        httpMethod.value.tags = httpMethod.value.tags.collect { tag ->
                            tag == "General" ? svc.name : tag
                        }
                    }
                }
            }
            specFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        }
    }
    tasks.named("generate$svc.name") { dependsOn ungroup }
}

import groovy.json.JsonSlurper
import groovy.json.JsonOutput

// Task to remove schemas with discriminators for dotnet only
project.ext.services.each { Service svc ->
    def removeDiscriminatorSchemas = tasks.register("removeDiscriminatorSchemas${svc.name}") {
        group 'specs'
        description "Remove schemas with discriminators from ${svc.name} for dotnet"
        dependsOn ':specs'
        
        // ONLY run for dotnet
        onlyIf { project.name == 'dotnet' }

        doLast {
            def specFile = file("$rootDir/schema/json/${svc.filename}")
            def json = new JsonSlurper().parse(specFile)

            if (json.containsKey("components") && json["components"].containsKey("schemas")) {
                def schemas = json["components"]["schemas"]
                def schemasToRemove = [] as Set
                
                // Step 1: Find schemas with discriminators
                schemas.each { Map.Entry schema ->
                    if (schema.value?.containsKey("discriminator")) {
                        schemasToRemove.add(schema.key)
                    }
                }
                
                // Helper function to check if an object contains a $ref to a removed schema
                def containsRefTo = { obj, Set targetSchemas ->
                    def checkRef
                    checkRef = { o ->
                        if (o instanceof Map) {
                            if (o.'$ref' instanceof String) {
                                def refName = o.'$ref'.tokenize('/').last()
                                if (targetSchemas.contains(refName)) return true
                            }
                            return o.values().any { checkRef(it) }
                        } else if (o instanceof List) {
                            return o.any { checkRef(it) }
                        }
                        return false
                    }
                    return checkRef(obj)
                }
                
                // Step 2: Recursively find all schemas that reference discriminated schemas
                def iteration = 0
                while (true) {
                    def newFound = [] as Set
                    schemas.each { Map.Entry schema ->
                        if (!schemasToRemove.contains(schema.key)) {
                            if (containsRefTo(schema.value, schemasToRemove)) {
                                newFound.add(schema.key)
                            }
                        }
                    }
                    if (newFound.isEmpty()) break
                    schemasToRemove.addAll(newFound)
                    iteration++
                    if (iteration > 10) break // Safety limit
                }
                
                println "Removing ${schemasToRemove.size()} schemas (with discriminators and their children) from ${svc.name} for dotnet: ${schemasToRemove}"
                schemasToRemove.each { schemaName ->
                    schemas.remove(schemaName)
                }
                
                // Step 3: Remove paths/endpoints that reference removed schemas
                def pathsToRemove = []
                if (json.containsKey("paths")) {
                    json["paths"].each { Map.Entry path ->
                        if (containsRefTo(path.value, schemasToRemove)) {
                            pathsToRemove.add(path.key)
                        }
                    }
                    
                    if (!pathsToRemove.isEmpty()) {
                        println "Removing ${pathsToRemove.size()} paths that reference discriminated schemas: ${pathsToRemove}"
                        pathsToRemove.each { pathName ->
                            json["paths"].remove(pathName)
                        }
                    }
                }
            }

            specFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        }
    }

    // Link the removal task to the generator task
    tasks.named("generate$svc.name") {
        dependsOn removeDiscriminatorSchemas
    }
}

// update OpenAPI file of the webhooks to add a custom extension 'x-webhook-root' to the model that represents the webhook payload
// this is necessary to generate the WebhookHandler that deserialises the Webhook models
project.ext.services.each { Service svc ->
    def addWebhookExtension = tasks.register("addWebhookExtension${svc.name}") {
        group 'specs'
        description "Add x-webhook-root extension to ${svc.name}"
        dependsOn ':specs'
        doLast {
            def specFile = file("$rootDir/schema/json/${svc.filename}")
            def json = new JsonSlurper().parse(specFile)

            // Check if the service name ends with "Webhooks"
            if (svc.name.endsWith("Webhooks") && json.containsKey("components") && json["components"].containsKey("schemas")) {
                json["components"]["schemas"].each { Map.Entry schema ->
                    def properties = schema.value?.properties
                    // add 'x-webhook-root' to the webhook model (we find 'environment' and 'data' attributes)
                    if (properties?.containsKey("environment") && properties?.containsKey("data")) {
                        schema.value["x-webhook-root"] = true
                    }
                    // add 'x-webhook-root' to RelayedAuthenticationRequest model (missing 'environment' and 'data' attributes)
                    // bespoke fix as the model doesn't adopt the standard schema
                    if (schema.key.equals("RelayedAuthenticationRequest")) {
                        schema.value["x-webhook-root"] = true
                    }
                    // add 'x-webhook-root' to DisputeNotificationRequest model
                    // bespoke fix as the model doesn't adopt the standard schema (missing 'environment' attribute)
                    if (schema.key.equals("DisputeNotificationRequest")) {
                        schema.value["x-webhook-root"] = true
                    }
                }
            }

            specFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        }
    }
    tasks.named("generate$svc.name") { dependsOn addWebhookExtension }
}

